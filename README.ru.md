# "Line" библиотека валидации для Go на основе дженериков

**Читать этот README на:**
[English](README.md) · [Русский](README.ru.md)

## Обзор

Этот проект — лёгкая и выразительная библиотека валидации для Go, предназначенная для описания и выполнения сложных правил валидации в декларативном и композиционном стиле. Она ориентирована на проверку значений, структур и коллекций с формированием структурированных и контекстно-зависимых ошибок.

Библиотека построена вокруг нескольких ключевых понятий: **ограничения (constraints)**, **аргументы**, **валидатор** и **нарушения (violations)**. Эти компоненты работают совместно, позволяя оставлять валидационную логику читаемой, переиспользуемой и легко расширяемой.

## Основные понятия

### Валидатор

Валидатор — это исполнительный механизм библиотеки. Он собирает аргументы валидации, применяет их в соответствующем контексте и агрегирует все нарушения в единый результат. Валидация всегда выполняется явно и возвращает либо `nil`, либо структурированный список нарушений.

Валидация учитывает контекст и поддерживает вложенные пути свойств, индексированные пути и группы валидации.

### Ограничения (Constraints)

Ограничения описывают, *какое правило* должно быть применено к значению. Каждое ограничение отвечает за проверку конкретного типа данных и за создание нарушения, если правило не выполнено.

Библиотека предоставляет богатый набор встроенных ограничений, включая:

* Ограничения наличия значения (пусто, не пусто, nil, не nil)
* Ограничения для строк (длина, точная длина, регулярные выражения)
* Числовые ограничения
* Ограничения для сравнимых значений (набор допустимых значений, равенство, диапазоны)
* Проверку форматов даты и времени
* Ограничения для коллекций (минимальное, максимальное, точное количество элементов, кратность)
* Ограничения на основе предикатов (JSON, целое число, числовое значение)

Ограничения являются неизменяемыми и поддерживают цепочки вызовов. Их можно настраивать с помощью:

* Условного выполнения
* Групп валидации
* Пользовательских ошибок
* Пользовательских шаблонов сообщений
* Параметров сообщений

### Аргументы

Аргументы связывают значения с ограничениями и определяют, *где* и *как* выполняется валидация. Аргумент представляет собой единицу валидации, которую можно привязать к пути свойства.

Библиотека предоставляет вспомогательные функции для аргументов:

* Скалярные значения (строки, числа, булевы значения, время)
* Nullable-значения
* Коллекции и итерируемые структуры
* Объекты, реализующие собственную валидацию
* Поэлементную валидацию срезов
* Условные сценарии валидации

Аргументы можно вкладывать, комбинировать и переиспользовать между валидаторами.

### Пути свойств

Каждое нарушение связано с путём свойства, который точно указывает, где произошла ошибка. Пути поддерживают:

* Точечную нотацию для свойств
* Индексацию для массивов и срезов
* Экранированные и кавычные имена свойств

Это делает результат валидации удобным для API, форм и структурированного вывода ошибок.

### Нарушения и ошибки

Когда ограничение не проходит проверку, создаётся нарушение. Нарушение содержит:

* Машиночитаемый идентификатор ошибки
* Человекочитаемое сообщение
* Полностью разрешённый путь свойства
* Подставленные параметры сообщения

Несколько нарушений собираются в единый объект ошибки, что позволяет обрабатывать все проблемы валидации одновременно.

Шаблоны сообщений поддерживают плейсхолдеры, которые во время выполнения заменяются фактическими значениями, лимитами или контекстными данными.

## Условная и групповая валидация

Валидацией можно управлять динамически с помощью условий и групп:

* Условное выполнение на основе логических выражений во время выполнения
* Групповая валидация для включения или отключения правил в зависимости от контекста
* Ветвление логики по принципу «если / иначе»
* Последовательная валидация с остановкой на первой ошибке
* Параллельная валидация независимых правил
* Логические композиции, такие как «все» или «хотя бы одно»

Это делает библиотеку подходящей для сложных бизнес-правил и многошаговых сценариев проверки.

## Расширяемость

Библиотека спроектирована так, чтобы её можно было расширять без изменения ядра:

* Пользовательские ограничения можно реализовывать через соответствующие интерфейсы
* Пользовательские предикаты легко оборачиваются в переиспользуемые ограничения
* Можно вводить собственные типы ошибок и шаблоны сообщений
* Доменные объекты могут становиться самопроверяемыми, реализуя единый интерфейс

## Цели проектирования

* Чёткое разделение описания валидации и её выполнения
* Строгая типизация без потери гибкости
* Минимальное использование рефлексии и предсказуемое поведение во время выполнения
* Структурированный вывод ошибок, подходящий для API и пользовательских интерфейсов
* Композиция из простых блоков вместо монолитных правил валидации

## Типовые сценарии использования

* Проверка входящих данных в HTTP API
* Обеспечение инвариантов на уровне доменной логики
* Валидация конфигураций и пользовательского ввода
* Проверка вложенных объектов и коллекций
* Условные сценарии валидации

## Итог

Эта библиотека предоставляет декларативный и композиционный подход к валидации в Go. Моделируя валидацию как комбинацию ограничений и аргументов, выполняемых валидатором, она позволяет описывать выразительные правила, получать точные отчёты об ошибках и гибко управлять логикой проверки, не жертвуя читаемостью и типобезопасностью.
